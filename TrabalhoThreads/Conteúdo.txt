
ğŸ¯ Objetivo

O programa implementa o problema clÃ¡ssico do Produtor-Consumidor, usando threads, semÃ¡foros e exclusÃ£o mÃºtua.
O buffer tem capacidade fixa (7 posiÃ§Ãµes) e serve como recurso compartilhado entre as threads.

âš™ï¸ Componentes principais
ğŸ”¹ Semaphore

empty â†’ controla o nÃºmero de posiÃ§Ãµes vazias.

full â†’ controla o nÃºmero de posiÃ§Ãµes cheias.
Eles garantem que:

Um produtor espere se o buffer estiver cheio.

Um consumidor espere se o buffer estiver vazio.

ğŸ”¹ ReentrantLock (mutex)

Garante que apenas uma thread por vez acesse a regiÃ£o crÃ­tica do buffer.

Evita condiÃ§Ãµes de corrida, impedindo que duas threads alterem o mesmo Ã­ndice simultaneamente.

ğŸ”¹ Buffer

Implementa os mÃ©todos produzir() e consumir().

O buffer Ã© circular â€” os Ã­ndices de inserÃ§Ã£o e remoÃ§Ã£o voltam ao inÃ­cio quando atingem o final.

TambÃ©m grava o log de cada operaÃ§Ã£o no arquivo log.txt.

ğŸ”¹ Produtor e Consumidor

SÃ£o threads (extends Thread) que usam o mesmo objeto Buffer.

O produtor cria atÃ© 15 itens (se houver espaÃ§o).

O consumidor remove atÃ© 12 itens (se houver itens disponÃ­veis).

ğŸ’¬ RelaÃ§Ã£o com o conteÃºdo de sala

SincronizaÃ§Ã£o: uso de semÃ¡foros e bloqueios garante acesso coordenado ao buffer.

ConcorrÃªncia e exclusÃ£o mÃºtua: controladas pelo ReentrantLock.

Deadlock prevention: a liberaÃ§Ã£o das permissÃµes segue ordem correta (lock â†’ aÃ§Ã£o â†’ unlock).

Problema do Produtor-Consumidor: exemplo prÃ¡tico de comunicaÃ§Ã£o indireta entre processos via memÃ³ria compartilhada.

âœ… ConclusÃ£o

O programa demonstra na prÃ¡tica:

Controle de concorrÃªncia com semÃ¡foros.

SincronizaÃ§Ã£o entre threads produtoras e consumidoras.

Registro de atividades em log.

CompreensÃ£o dos conceitos teÃ³ricos de mutex, sincronizaÃ§Ã£o, e buffers limitados.